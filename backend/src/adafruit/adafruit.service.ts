import { Injectable } from '@nestjs/common';
import { Device, DeviceType } from '@prisma/client';
import { DateTime } from 'luxon';

@Injectable()
export class AdafruitService {
  private readonly AIO_USERNAME = 'leduy1204';
  private readonly AIO_KEY = 'aio_geGY19NFH3nv6m1rAj3unlge1M1q';
  private readonly BASE_URL = `https://io.adafruit.com/api/v2/${this.AIO_USERNAME}`;

  // L·∫•y d·ªØ li·ªáu t·ª´ m·ªôt feed v√† chuy·ªÉn ƒë·ªïi th·ªùi gian v·ªÅ Asia/Ho_Chi_Minh (UTC+7)
  async getFeedData(feedName: string): Promise<any> {
    const url = `${this.BASE_URL}/feeds/${feedName}/data`;
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'X-AIO-Key': this.AIO_KEY },
    });

    if (!response.ok) {
      throw new Error(`‚ùå Failed to fetch feed data: ${response.statusText}`);
    }

    const data = await response.json();

    // Chuy·ªÉn ƒë·ªïi th·ªùi gian v·ªÅ UTC+7
    return data.map((item: any) => ({
      ...item,
      created_at: DateTime.fromISO(item.created_at, { zone: 'utc' })
        .setZone('Asia/Ho_Chi_Minh')
        .toFormat('yyyy-MM-dd HH:mm:ss'),
    }));
  }

  // G·ª≠i d·ªØ li·ªáu l√™n Adafruit IO
  async sendFeedData(feedName: string, value: string): Promise<any> {
    const url = `${this.BASE_URL}/feeds/${feedName}/data`;
  
    console.log(`üîπ Sending request to: ${url} with value: ${value}`);
  
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'X-AIO-Key': this.AIO_KEY,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ value: `${value}` }), // ƒê·∫£m b·∫£o `value` l√† string
    });
  
    if (!response.ok) {
      const errorText = await response.text(); // L·∫•y n·ªôi dung l·ªói
      throw new Error(`‚ùå Failed to send feed data: ${response.status} - ${errorText}`);
    }
  
    return response.json();
  }
  

  private pollingIntervals: Map<string, NodeJS.Timeout> = new Map();

  // L·∫•y d·ªØ li·ªáu g·∫ßn nh·∫•t t·ª´ m·ªôt feed
  async getLatestFeedData(feedName: string): Promise<any> {
    const url = `${this.BASE_URL}/feeds/${feedName}/data?limit=1`;
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'X-AIO-Key': this.AIO_KEY },
    });

    if (!response.ok) {
      throw new Error(`‚ùå Failed to fetch latest feed data: ${response.statusText}`);
    }

    const data = await response.json();
    if (data.length === 0) return null;

    // Chuy·ªÉn ƒë·ªïi th·ªùi gian v·ªÅ UTC+7
    return {
      ...data[0],
      created_at: DateTime.fromISO(data[0].created_at, { zone: 'utc' })
        .setZone('Asia/Ho_Chi_Minh')
        .toFormat('yyyy-MM-dd HH:mm:ss'),
    };
  }

  // Polling li√™n t·ª•c ƒë·ªÉ l·∫•y d·ªØ li·ªáu m·ªõi nh·∫•t t·ª´ feed
  startPollingFeed(feedName: string, intervalMs: number, callback: (data: any) => void): void {
    if (this.pollingIntervals.has(feedName)) {
      console.warn(`‚ö†Ô∏è Polling for feed '${feedName}' is already running.`);
      return;
    }

    console.log(`üöÄ Starting polling for feed '${feedName}' every ${intervalMs / 1000}s...`);
    const interval = setInterval(async () => {
      try {
        const latestData = await this.getLatestFeedData(feedName);
        if (latestData) callback(latestData);
      } catch (error) {
        console.error(`‚ùå Error fetching feed '${feedName}':`, error);
      }
    }, intervalMs);

    this.pollingIntervals.set(feedName, interval);
  }

  // D·ª´ng polling cho m·ªôt feed c·ª• th·ªÉ
  stopPollingFeed(feedName: string): void {
    if (this.pollingIntervals.has(feedName)) {
      clearInterval(this.pollingIntervals.get(feedName)!);
      this.pollingIntervals.delete(feedName);
      console.log(`üõë Stopped polling for feed '${feedName}'.`);
    }
  }

  // D·ª´ng to√†n b·ªô polling khi module b·ªã h·ªßy
  onModuleDestroy() {
    this.pollingIntervals.forEach((interval, feedName) => {
      clearInterval(interval);
      console.log(`üõë Stopped polling for feed '${feedName}' (module destroy).`);
    });
    this.pollingIntervals.clear();
  }

  getFeedNames(device: Device): string[] {
    if (device.type === DeviceType.MOISTURE_SENSOR) {
      return [device.name]; // L·∫•y tr·ª±c ti·∫øp t·ª´ name
    }
    if (device.type === DeviceType.DHT20_SENSOR) {
      const identifier = device.name.replace(/^DHT20/, ''); // Lo·∫°i b·ªè ti·ªÅn t·ªë "DHT20"
      return [`nhietdo${identifier}`, `doam${identifier}`];
    }
    return [];
  }
}
